# Fresnel

Fresnel is an offline task system that uses Redis and Node.js to keep track of
tasks and push them out to ancillary worker processes. It is inspired by
[Resque](http://github.com/defunkt/resque), [Flickr's Offline Task
system(s)](http://code.flickr.com/blog/2008/09/26/flickr-engineers-do-it-offline/),
and others.

## Design Goals

* tasks are deliberately time-limited (duration TBD) to encourage breaking them
  up into bite-sized chunks.
* queued tasks will always be run
* tasks must be idempotent, as they may be run more than once
* incomplete (failing) tasks will be retried until a retry limit has been
  reached
* tasks may be scheduled in the future
* tasks with matching arguments are considered duplicate tasks
* HTTP and JSON are used for maximal interoperability

## Task definitions

The "public" (initiator- and worker-facing) JSON description of a task looks
like:

    {
        "class": "UserBackfill",
        "args": [
            "12"
        ]
    }

This is the payload that is both used to create tasks and passed to worker
processes. _an `id` parameter may be included when sent to a worker._

The internal task definition looks like this:

    {
        "class": "UserBackfill",
        "args": [
            "12"
        ],
        "id": "6642e79e377a19e6dc23cbc3eb96830aa0370042",
        "attempts": 0,
        "state": "ready",
        "lastError": null,
        "queuedAt": "",
        "firstRunAt": "",
        "reservedAt": "",
        "lastRunAt": "",
        "firstScheduledFor": "",
        "scheduledFor": "",
        "lastRunBy": "",
        "priority": ""
    }

### States

The following states are valid:

* ready
* reserved
* running
* failed
   * TODO break into multiple reasons
   * timed-out

## Task ids

Task ids are generated by taking the SHA of the task description (sans
whitespace).

TODO consider `INCR`ing `next.tasks.id` for actual ids, reserving the use of
SHAs for uniqueness within the set of pending tasks.

## Redis Keys

The following Redis data structures are used (prefixed with a user-defined
value, `fresnel` by default):

* `tasks:<id>` - string value containing internal task definition
* `tasks` - set containing ids of all pending / running tasks (for uniqueness
  checks)
* `<queue>` - sorted set containing ids of pending / running tasks for a
  particular queue (sort key = `scheduledFor`)
* `<queue>_by_priority` - sorted set containing ids of pending / running tasks
  with a particular priority (sort key = `priority`)
* `<queue>_reservoir` - sorted set containing ids of tasks scheduled for the
  future (`scheduledFor` > now) (sort key = `scheduledFor`)
* `<queue>_failed` - sorted set containing ids of failed tasks (sort key =
  `attempts`)
* `<queue>_pending` - sorted set containing ids of reserved (in Fresnel's local
  buffer) tasks (sort key = `reservedAt`)
* `<queue>_error` - set containing tasks that passed the retry limit (TODO there
may be duplicates if the same task is [intentionally] queued/run multiple times)
* `<queue>_invalid` - set containing ids of invalid tasks (invalid JSON, etc.)
* `errors:<id>` - string value containing the most recent error output for a
  failed task

## Metrics

* lifetime (completion time - `queuedAt`)
* time-to-completion (completion time - `firstRunAt`)
* time-to-failure (retry expiration - `queuedAt`)
* runtime (completion time - `reservedAt`)
* latency (time started - `firstScheduledFor`)
* number of attempts required
* number of tasks by queue
* number of tasks by queue by state
* number of tasks by priority
* number of tasks by priority by state
* number of tasks by queue by priority by state
* number of tasks by state
* number of waiting tasks
* tasks queued/second
* tasks run/second

## Web Interface

TDB

## Mapping Tasks to Workers

    fresnel.WORKER_MAP = {
        "queue": {
            "Class": "http://localhost:8080/jobs/sample"
        },
        "backfill": {
            "Backfill": "http://localhost:8080/jobs/backfill"
        },
        "test": {
            "Load": "http://localhost:8081/"
        },
        "echo": {
            "*": "http://localhost:8081/"
        }
    };

## Intervals / Periodic Actions

The following actions need to occur on a regular basis:

* draining ready tasks from the reservoir to the main queue
* buffering waiting tasks into `<queue>_pending` and Fresnel's local queue
* running locally buffered tasks
* moving failed tasks (retry limit exceeded) to `<queue>_error`
* collecting metrics

## Events

When a task completes (the HTTP request ends), some of the following actions
should be taken:

* add/update `<queue>_failed` and reschedule into `<queue>_reservoir` as
  appropriate
* remove from `<queue>_pending`
* remove from `tasks` and `tasks:<id>` as appropriate
* update metrics

## Concurrency Controls

The concurrency of the following operations is configurable:

* number of running tasks per queue

## Dependencies

Fresnel depends on Node.js >= 1.100, Redis 2.0.0RC1+,
[redis-node-client](http://github.com/fictorial/redis-node-client), and
[hashlib](http://github.com/brainfucker/hashlib).

## Installing

Follow the instructions for hashlib to add it to Node's `require.path`.

## Starting

    $ NODE_PATH=../../fictorial/redis-node-client/lib/:lib/ node fresnel.js
